# Концепция проекта

### [⬅️Вернуться в README](../../README.md)

## Оглавление
- [Введение](#введение)
  - [Проблемы Unity](#проблемы-unity)
    1. [Инициализация](#инициализация)
       + [ExecutionOrder](#execution-order)
       + [Composition Root](#composition-root)
       + [DI Container](#di-container)
    2. [Сцены](#сцены)
       + [Производительность](#производительность)
       + [Перенос данных](#перенос-данных)
       + [Слияние веток в Git](#слияние-веток-в-git)
    3. [Безопасность](#безопасность)

## Введение
В процессе разработки игр в Unity, рано или поздно разработчики сталкиваются с фундаментальными проблемами, которые существенно влияют на скорость и удобство развития проекта, а также на его дальнейшую поддержку.
Эти проблемы можно условно разделить на две большие группы:

- ### Проблемы Unity

  1. **Инициализация**<a id="инициализация"></a><br>
    Проблема возникает, когда один компонент требует другой в качестве зависимости, что часто встречается при декомпозиции. В простейшем случае, если оба объекта изначально находятся на сцене, зависимость можно передать через инспектор. Однако если передаваемый объект также требует инициализации, становится критически важен порядок выполнения, иначе возможны ошибки или некорректное поведение из-за взаимодействия с неинициализированным объектом.
    <br>Удобно контролировать этот процесс стандартными средствами Unity невозможно, поскольку порядок вызовов `Awake` и `Start` для разных объектов определяется внутренними механизмами движка и не может быть изменён напрямую.
    <br>Ситуация усложняется, если объекты создаются во время выполнения игры. Например, если объект должен подписываться и отписываться на события, зависимость требуется уже в `OnEnable`, но передать её через инспектор невозможно.
    <br><br>Основные способы решения проблемы:

       - **ExecutionOrder**<a id="execution-order"></a> — самый простой способ управления порядком выполнения скриптов в Unity, но его масштабируемость оставляет желать лучшего. Приоритеты приходится задавать вручную вне скриптов, что создаёт неявные связи между типами и усложняет поддержку проекта. Кроме того, этот метод не подходит для динамически создаваемых объектов, поскольку событийные методы Unity выполняться раньше чем вызов любого другого метода на компоненте объекта.

       - **Composition Root**<a id="composition-root"></a> — это самый гибкий подход, но он имеет серьёзные ограничения в масштабируемости. Требуется вручную прописывать передачу всех объектов, что делает его неудобным для крупных проектов, где огромное количество компонентов. Кроме того, этот метод также не решает проблему внедрения зависимостей в динамически создаваемые объекты.

       - **DI Container**<a id="di-container"></a> - один из самых удобных способов разрешения зависимостей, особенно в сложных проектах. Однако логика их распределения становится менее очевидной, а реализация иногда требует много дополнительного кода.

  2. **Сцены**<a id="сцены"></a><br>
    В Unity сцены имеют несколько проблемных мест:
     
     + **Производительность**<a id="производительность"></a><br>
        При загрузке новой сцены все объекты текущей сцены уничтожаются, а затем инициализируются новые экземпляры. Частые переходы между одинаковыми или схожими сценами приводят к избыточному расходу ресурсов, так как каждый раз происходит полное удаление и создание объектов вместо их повторного использования.

     + **Перенос данных**<a id="перенос-данных"></a><br>
        В Unity отсутствует удобный встроенный механизм передачи данных между сценами, поэтому приходится использовать статические хранилища или `DontDestroyOnLoad`. Однако эти методы небезопасны, поскольку данные остаются доступными для изменения из любого места кода.
        <br>Альтернативой является Typed Scenes – инструмент для передачи строго типизированных данных при загрузке сцены. Хотя он и решает проблему, но имеет ряд ограничений, а его разработка давно прекращена.

     + **Слияние веток в Git**<a id="слияние-веток-в-git"></a><br>
        В Unity отсутствует встроенный механизм разрешения конфликтов при слиянии веток, что создаёт сложности, особенно с YAML-файлами сцен. Приходится использовать сторонние инструменты, такие как Unity Smart Merge, но даже он не гарантирует полного устранения всех конфликтов.

  3. **Безопасность**<a id="безопасность"></a><br>
    В Unity любой компонент может получить доступ к любому объекту и изменить его, тем самым ни о какой защите инвариантов объектов не идёт и речи, максимум, что можно сделать это инкапсулировать свои собственные компоненты. Подобное решение от разработчиков Unity хоть и даёт невероятную гибкость, но может легко приводить к ошибкам времени выполнения.

- ### Проблемы парадигм
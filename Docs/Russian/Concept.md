# Концепция проекта

### [⬅️Вернуться в README](../../README.md)

## Оглавление
- [Введение в проблему](#введение-в-проблему)
  - [Проблемы Unity](#проблемы-unity)
    - [Инициализация](#инициализация)
    - [Сцены](#сцены)
    - [Безопасность](#безопасность)
  - [Проблемы парадигм](#проблемы-парадигм)
    - [ФП (Функциональное программирование)](#фп)
    - [ПП (Процедурное программирование)](#пп)
    - [ООП (Объектно-ориентированное программирование)](#ооп)
    - [РП (Реактивное программирование)](#рп)
    - [(DOD) (Data-Oriented Design)](#dod)
    - [Другие](#другие)
- [Решение](#решение)
  - [Требования к новой парадигме](#требования-к-новой-парадигме)

## Введение в проблему
В процессе разработки игр в Unity, рано или поздно разработчики сталкиваются с фундаментальными проблемами, которые существенно влияют на скорость и удобство развития проекта, а также на его дальнейшую поддержку.
Эти проблемы можно условно разделить на две большие группы:

- ### Проблемы Unity

  1. **Инициализация**<a id="инициализация"></a><br>
      Проблема возникает, когда один компонент требует другой в качестве зависимости, что часто встречается при декомпозиции. В простейшем случае, если оба объекта изначально находятся на сцене, зависимость можно передать через инспектор. Однако если передаваемый объект также требует инициализации, становится критически важен порядок выполнения, иначе возможны ошибки или некорректное поведение из-за взаимодействия с неинициализированным объектом.
      <br>Удобно контролировать этот процесс стандартными средствами Unity невозможно, поскольку порядок вызовов `Awake` и `Start` для разных объектов определяется внутренними механизмами движка и не может быть изменён напрямую.
      <br>Ситуация усложняется, если объекты создаются во время выполнения игры. Например, если объект должен подписываться и отписываться на события, зависимость требуется уже в `OnEnable`, но передать её через инспектор невозможно.
      <br><br>Основные способы решения проблемы:

      - **ExecutionOrder** — самый простой способ управления порядком выполнения скриптов в Unity, но его масштабируемость оставляет желать лучшего. Приоритеты приходится задавать вручную вне скриптов, что создаёт неявные связи между типами и усложняет поддержку проекта. Кроме того, этот метод не подходит для динамически создаваемых объектов, поскольку событийные методы Unity выполняться раньше чем вызов любого другого метода на компоненте объекта.

      - **Composition Root** — это самый гибкий подход, но он имеет серьёзные ограничения в масштабируемости. Требуется вручную прописывать передачу всех объектов, что делает его неудобным для крупных проектов, где огромное количество компонентов. Кроме того, этот метод также не решает проблему внедрения зависимостей в динамически создаваемые объекты.

      - **DI Container** - один из самых удобных способов разрешения зависимостей, особенно в сложных проектах. Однако логика их распределения становится менее очевидной, а реализация иногда требует много дополнительного кода.

  2. **Сцены**<a id="сцены"></a><br>
      В Unity сцены имеют несколько проблемных мест:
     
     + **Производительность**<br>
        При загрузке новой сцены все объекты текущей сцены уничтожаются, а затем инициализируются новые экземпляры. Частые переходы между одинаковыми или схожими сценами приводят к избыточному расходу ресурсов, так как каждый раз происходит полное удаление и создание объектов вместо их повторного использования.

     + **Перенос данных**<br>
        В Unity отсутствует удобный встроенный механизм передачи данных между сценами, поэтому приходится использовать статические хранилища или `DontDestroyOnLoad`. Однако эти методы небезопасны, поскольку данные остаются доступными для изменения из любого места кода.
        <br>Альтернативой является Typed Scenes – инструмент для передачи строго типизированных данных при загрузке сцены. Хотя он и решает проблему, но имеет ряд ограничений, а его разработка давно прекращена.

     + **Слияние веток в Git**<br>
        В Unity отсутствует встроенный механизм разрешения конфликтов при слиянии веток, что создаёт сложности, особенно с YAML-файлами сцен. Приходится использовать сторонние инструменты, такие как Unity Smart Merge, но даже он не гарантирует полного устранения всех конфликтов.

  3. **Безопасность**<a id="безопасность"></a><br>
      В Unity любой компонент может получить доступ к любому объекту и изменить его, тем самым ни о какой защите инвариантов объектов не идёт и речи, максимум, что можно сделать это инкапсулировать свои собственные компоненты. Подобное решение от разработчиков Unity хоть и даёт невероятную гибкость, но может легко приводить к ошибкам времени выполнения.

- ### Проблемы парадигм
Проблема выбора лучшей парадигмы в программировании касается не только Unity или геймдева, но стоит понимать, что очень многие сложности и проблемы связаны именно с этим, поэтому вот краткий обзор основных недостатков наиболее распространённых подходов:

  1. **ФП** (Функциональное программирование)<a id="фп"></a><br>
     - **Отрыв от реального мира**<br>
         Реальный мир полон изменяющихся состояний: климат меняется, люди взаимодействуют, экономика колеблется, живые организмы адаптируются. Однако функциональное программирование избегает явного хранения состояния, опираясь на вычисления и передачу данных через аргументы функций. Это усложняет моделирование долгосрочных процессов, таких как работа с базами данных или управление пользовательскими сессиями, требуя дополнительных абстракций. В итоге программная модель ФП оказывается менее естественной для работы с динамическими системами, где сохранение и изменение состояния являются необходимостью.

     - **Плохая производительность**<br>
         Одной из основ функционального программирования являются неизменяемые структуры данных, что увеличивает потребление памяти, поскольку каждое изменение требует создания новой копии объекта. Кроме того, отсутствие явного управления состоянием затрудняет оптимизацию использования ресурсов, особенно в высоконагруженных системах.

  2. **ПП** (Процедурное программирование)<a id="пп"></a><br> 
     - **Сложность поддержки и масштабирования**<br>
         По мере роста проекта процедурный код становится все более запутанным, а сложные зависимости между процедурами затрудняют внесение изменений. Отсутствие четкой модульности делает систему хрупкой, где любые правки могут привести к неожиданным последствиям. Глобальные переменные это ключевая проблема ПП, затрудняющая сопровождение кода, снижая его безопасность и создавая препятствия для стабильной работы в многопоточных средах.
   
  3. **ООП** (Объектно-ориентированное программирование)<a id="ооп"></a><br>
     - **Избыточные абстракции**<br>
         Объектно-ориентированное программирование часто страдает от переусложненных абстракций, где одни абстракции строятся на других, создавая запутанные иерархии. Это затрудняет понимание кода, усложняет поддержку и делает систему менее предсказуемой. Избыточная гибкость ООП также дает простор для неудачных архитектурных решений, когда чрезмерное использование наследования, интерфейсов и паттернов приводит к неоправданной сложности, мешающей эффективной разработке.

  4. **РП** (Реактивное программирование)<a id="рп"></a><br>
     - **Сложность отладки и управления потоками данных**<br>
         Реактивное программирование затрудняет процесс отладки и снижает предсказуемость системы из-за асинхронности и динамического распространения изменений. Взаимозависимые потоки данных могут приводить к неожиданным ошибкам, а некорректное управление подписками часто вызывает утечки памяти, снижая стабильность приложения.

  5. **(DOD)** (Data-Oriented Design)<a id="dod"></a><br>
     - **Сложность восприятия**<br>
         Data-Oriented Design требует разделения данных и логики, что противоречит естественному восприятию информации человеком. Мы привыкли работать с данными и их обработкой как с единым целым, а DOD заставляет мыслить ими отдельно, что усложняет проектирование и понимание системы.

     - **Отсутствие защиты данных**<br>
         Data-Oriented Design основан на глобальных состояниях, поскольку данные обрабатываются отдельно от логики. Это повышает производительность, но одновременно усложняет контроль над изменениями и увеличивает риск ошибок.
 
     - **Сложность работы с иерархическими структурами данных**<br>
         Data-Oriented Design использует линейное хранение и обработку данных, что затрудняет представление сложных иерархических структур. В DOD связи между элементами не создаются автоматически, а требуют явного управления, что усложняет их реализацию и обновление.

### Другие
Помимо рассмотренных популярных парадигм, существуют и другие подходы к программированию. Однако большинство из них либо обладают узкой специализацией и применяются только в сочетании с другими подходами, либо оказались неэффективными и не получили широкого распространения. В связи с этим их детальное рассмотрение не представляется целесообразным.

## Решение
Проанализировав существующие проблемы, я пришёл к выводу, что необходимо попытаться разработать новую парадигму программирования, способную устранить выявленные недостатки. В этом контексте проект **Serein** станет экспериментальным фреймворком для Unity, предоставляющим возможность писать код в рамках этой новой концепции. 

### Требования к новой парадигме

1. **Простота и выразительность** – код должен быть интуитивно понятным, самодокументируемым и естественным для восприятия.

2. **Гибкость и адаптивность** – парадигма должна легко подстраиваться под различные задачи и позволять эволюцию без жёстких ограничений.

3. **Безопасность и отказоустойчивость** – парадигма должна минимизировать уязвимости и предотвращать ошибки на всех уровнях разработки.

4. **Высокая производительность** – вычисления и обработка данных должны быть максимально эффективными без ущерба удобству разработки.

5. **Простота тестирования и диагностики** - процессы проверки должны быть естественной частью разработки, позволяя быстро выявлять и устранять ошибки.

6. **Минимизация рутины и технических преград** – разработка должна быть сфокусирована на выражении намерений, а не борьбе с техническими деталями.

7. **Согласованность и предсказуемость** – единые принципы работы исключают неожиданные поведения, обеспечивая стабильность и улучшая удобство сопровождения.

8. **Масштабируемость** – принципы должны оставаться эффективными независимо от размеров и сложности проекта.

9.  **Человекоориентированность** – принципы должны соответствовать естественному ходу мыслей разработчика, уменьшая сложность восприятия и взаимодействия с кодом.
